PC MARKET
=
TEST TASK FOR SHIFTLAB
=

Описание проекта
-

Данный проект был написан в рамках тестового задания к ШИФТЛАБ от ЦФТ<br>

Проект представляет из себя back-end часть web-сервиса "магазина техники"
<br><br>


### Техническое задание:


*В магазине есть следующие типы товаров:* 
* Настольные компьютеры
* Ноутбуки 
* Мониторы
* Жесткие диски

*Каждый товар имеет следующие свойства:*
* номер серии
* производитель
* цена
* количество единиц продукции на складе

*Дополнительные свойства товаров:*
* Настольные компьютеры имеют форм-фактор: десктопы, неттопы, моноблоки
* Ноутбуки подразделяются по размеру: 13, 14, 15, 17 дюймовые
* Мониторы имеют диагональ
* Жесткие диски имеют объем

*Необходимо реализовать back-end приложение, которое имеет RESTful HTTP методы выполняющие:*
1) Добавление товара
2) Редактирование товара
3) Удаление товара
4) Просмотр всех существующих товаров по типу
5) Просмотр товара по идентификатору
<br>

Использованные технологии
-
* Система сборки проекта **Maven**
* Для написания проекта был использован фреймворк **Spring Boot 2**
* Был использован интерфейс **RESTful API**
* Для логирования основных моментов исполнения программы была использована
  библиотека **log4j2**
* Для тестирования был использован фреймворк **Mockito**
* Была использована in-memory DataBase **"H2"**
* Для связи объектов и реляционного представления данных был использован фреймворк **Hibernate**
* Документация была написана с помощью **Javadoc**


Основные возможности и моменты реализации на основе требований:
-
* Был создан абстрактный класс `ProductEntity`, от которого наследовались (со стратегией
`Joined`) все остальные сущности: 
  - `PcEntity`
  - `HddEntity`
  - `LaptopEntity`
  - `MonitorEntity`
* Стратегия наследования `Joined` была выбрана с целью объединения всех товаров в одном месте.
Уникальные аттрибуты сущностей хранятся в отдельных таблицах. Они связаны с таблицей *продуктов*
по id, которые генерируются автоматически при добавлении нового поля.
![DB_scheme_UML](https://github.com/tarihay/TestTask_ShiftLab/blob/master/DB_scheme_Diagram.png)
* При добавлении новой сущности, *интерфейсы*, наследующие `JpaRepository`, генерируют 
запросы в базу данных, автоматически распределяя поля по базам (какие аргументы идут в общую таблицу, 
а какие в таблицу сущности этого типа)
* Ограничение по количеству сущностей было реализовано с помощью Enum. При условии масштабирования
приложения, нужно добавить его в этот класс и добавить несколько методов, которые будут обрабатывать
**GET** и **POST** запросы для этих сущностей
* Была использована многоуровневая схема web-приложения <br>
(Controller => Service => Repository)<br>
* Было написано несколько контроллеров, разделенных по функционалу: 
  - Контроллер **добавления** товаров (`AddProductController`)
  - Контроллер **поиска** товаров (`SearchProductController`)
  - Контроллер **удаления** товаров (`DeleteProductController`)
  - Контроллер **обновления** данных уже существующих товаров (`UpdateProductController`)

О каждом контроллере поговорим отдельно.

### AddProductController
Содержит четыре метода, обрабатывающие **POST-запросы** по добавлению товара.

1) Запрос на добавление *ПК* **должен** выглядеть так:<br>
endpoint: `localhost:8184/market/add/pc`
````
{
	"serialNumber":"aaaaa",
	"manufacturer":"ASUS",
	"priceValue":111,
	"productType":"PC",
	"amount":123,
	"formFactor":"NETTOP"
}
````
аттрибут *formFactor* может принимать только значения, находящиеся в Enum'e
*`PcFormFactors`*

2) Запрос на добавление *Жесткого диска* **должен** выглядеть так:<br>
   endpoint: `localhost:8184/market/add/hdd`
````
{
	"serialNumber":"aaaaax12344",
	"manufacturer":"HDDPRO",
	"priceValue":1,
	"productType":"HDD",
	"amount":1233,
	"memoryVolumeValue":1,
	"memoryVolume":"GB"
}
````
аттрибут *memoryVolume* может принимать только значения, находящиеся в Enum'e
*`MemoryVolumeOptions`*

3) Запрос на добавление *Ноутбука* **должен** выглядеть так:<br>
   endpoint: `localhost:8184/market/add/laptop`
````
{
	"serialNumber":"5555",
	"manufacturer":"Mag",
	"priceValue":1111111,
	"productType":"LAPTOP",
	"amount":1,
	"size":"FOURTEEN"
}
````
аттрибут *size* может принимать только значения, находящиеся в Enum'e
*`LaptopSize`*

4) Запрос на добавление *Монитора* **должен** выглядеть так:<br>
   endpoint: `localhost:8184/market/add/monitor`
````
{
	"serialNumber":"abcd1234",
	"manufacturer":"LENOVO",
	"priceValue":10000,
	"productType":"MONITOR",
	"amount":13,
	"diagonalSize":1234
}
````

*После выполнения операции добавления пользователю будет возврщено **id** добавленного в базу
объекта. В случае ошибки пользователь будет уведомлен, что с его данными что-то не так*

### DeleteProductController
Содержит единственный метод, обрабатывающий **POST-запрос**: *удаление по id* <br>
endpoint: `localhost:8184/market/delete/{id}`. 
Вместо {id} должен быть идентификатор товара, который нужно удалить

В случае успешного удаления, пользователь будет уведомлен об этом. 
В случае ненахождения сущности с таким *id*, пользователь будет предупрежден, что 
товара с таким *id* нет

### SearchProductController
Содержит 5 методов, обрабатывающие **GET-запросы**:
* Поиск товара по *id* <br>
endpoint: `localhost:8184/market/search/{id}`<br>
Сначала метод смотрит какого типа продукт с таким id, после чего
находит в базе данных этого типа сущность с таким идентификатором и возвращает ее пользователю <br>
В случае ненахождения записи с таким id, пользователь будет предупрежден об этом
* Поиск всех товаров по типу <br>
endpoint: `localhost:8184/market/search/byType?productType={TYPE}` <br>
Возвращает список всех товаров типа TYPE из базы данных. В случае отсутствия товаров этого типа, 
пользователь будет предупрежден об этом<br>
_Примечание:_ типы товаров находятся в Enum'e `ProductTypes`<br>
`PC, HDD, LAPTOP, MONITOR`


### UpdateProductController
Содержит метод, обрабатывающий **PATCH-запрос** обновления записи с данным *id*: <br>
endpoint: `localhost:8184/market/update/{id}`. Вместо {id} нужно ввести идентификатор нужного товара. <br>
На вход поступает Json-объект специального формата, который objectMapper успешно парсит
и понимает что конкретно нужно делать. <br>
Json-объект в данном случае это JsonPatch, который должен иметь следующий формат.
*Пример*: <br>
````
[
	{
	    "op":"replace",
	    "path":"/memoryVolume",
	    "value":"GB"
	}
]
````
_Примечание 1:_ Этот пример подходит только для сущности **Жесткого диска**, так как здесь используется
уникальный для этого товара аттрибут

_Примечание 2:_ квадратные скобочки вокруг Json-объекта обязательны

### Сервисы
Следующий слой приложения состоит из сервисов. <br>
Они реализуют распаковку пришедших DTO и прямую работу с репозиториями сущностей <br>
Любой из контроллеров может использовать несколько сервисов для реализации своей логики

Инструкция по проверке функционала приложения
-
* Чтобы запустить приложение, нужно:
  1) В консоли зайти в папку проекта. Вы должны увидеть файл `pom.xml`
  2) Вы должны упаковать проект в jar-файл с помощью команды `mvn package`. Проект скомпилируется, создастся 
  папка **/target**, внутри которой будет лежать файл `market-1.0.0.jar` 
  3) Теперь с помощью команды `java -jar target/market-1.0.0.jar` можно запустить образ проекта
  Проверить, запустился сервис или нет можно по логам. В случае успеха, можно увидеть сообщение <br>
  `Tomcat started on port(s): 8184 (http) with context path ''`
* Первоначальные настройки базы данных производятся автоматически, что можно увидеть в логах запуска приложения
* Проверку функционала рекомендуется делать через Postman. Все необходимые endpoint'ы и
форматы Json-объектов для любого из запросов описаны выше <br>
* Проверку функционала также можно осуществить из командной строки с помощью `curl`: <br>
    1) Пример добавления товара с помощью POST запроса будет выглядеть так: <br>
       ```
       curl -H "Content-Type: application/json" -X POST -d {"serialNumber":"aaaaa","manufacturer":"Maxim","priceValue":111,"productType":"PC","amount":123,"formFactor":"NETTOP"} "localhost:8184/market/add/pc"
       ```
    2) Пример поиска товара с помощью GET запроса будет выглядеть так: <br>
       ```
       curl -X GET "localhost:8184/market/search/pcs"
       ```
    3) Пример обновления товара с помощью PATCH запроса будет выглядеть так: <br>
       ```
       curl -H "Content-Type: application/json" -X PATCH -d {"op":"replace","path":"/formFactor","value":"DESKTOP"} "localhost:8184/market/update/1"
       ```
    4) Пример удаления товара с помощью DELETE запроса будет выглядеть так: <br>
       ```
       curl -X DELETE "localhost:8184/market/delete/1"
       ```
_Примечание_: гайд по настройке выше был написано для ОС Windows
* Посмотреть и пощупать базу данных можно по след адресу:`localhost:8184/h2` (запускать в браузере) <br>
Имя базы: `jdbc:h2:mem:marketDB`, логин: **admin**, пароль: **admin**. <br>
* В интерфейсе Базы Данных в вашем браузере можно автоматически генерировать SQL-запросы
для удобного поиска информации. Достаточно нажать на интересующую вас базу и нажать `RUN`. 
После этого нужно поправить запрос, чтобы сделать новый (по другой бд, например)

_Примечание для всех пунктов, кроме первого:_ приложение должно быть запущено!

### Что еще можно сделать, но не сделано

* Написать больше тестов на все ситуации, которые могут произойти
* Добавить **Swagger** и написать удобную и понятную документацию
